"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var gqlAssert_1 = require("../util/gqlAssert");
var SdlExpect = /** @class */ (function () {
    function SdlExpect() {
    }
    /**
     * Assertion helper for fields.
     */
    SdlExpect.field = function (candidate, name, required, list, type, isId, isReadOnly, defaultValue) {
        if (isId === void 0) { isId = false; }
        if (isReadOnly === void 0) { isReadOnly = false; }
        if (defaultValue === void 0) { defaultValue = null; }
        var fieldObj = candidate.fields.filter(function (f) { return f.name === name; })[0];
        if (fieldObj === undefined) {
            gqlAssert_1.default.raise("Field " + name + " not found. Existing fields: " + candidate.fields
                .map(function (f) { return f.name; })
                .join(', '));
        }
        expect(fieldObj.isRequired).toEqual(required);
        expect(fieldObj.isList).toEqual(list);
        expect(fieldObj.type).toEqual(type);
        expect(fieldObj.defaultValue).toEqual(defaultValue);
        expect(fieldObj.isId).toEqual(isId);
        expect(fieldObj.isReadOnly).toEqual(isReadOnly);
        expect(fieldObj.defaultValue).toEqual(defaultValue);
        return fieldObj;
    };
    /**
     * Assertion helper for errors.
     */
    SdlExpect.error = function (object) {
        expect(object.comments).toBeDefined();
        if (object.comments !== undefined) {
            expect(object.comments.some(function (x) { return x.isError; }));
        }
    };
    /**
     * Assertion helper for types
     */
    SdlExpect.type = function (types, name, isEnum, isEmbedded) {
        if (isEnum === void 0) { isEnum = false; }
        if (isEmbedded === void 0) { isEmbedded = false; }
        var type = types.filter(function (t) { return t.name === name; })[0];
        if (type === undefined) {
            gqlAssert_1.default.raise("Type " + name + " not found. Existing types: " + types
                .map(function (t) { return t.name; })
                .join(', '));
        }
        expect(type.isEnum).toEqual(isEnum);
        expect(type.isEmbedded).toEqual(isEmbedded);
        return type;
    };
    SdlExpect.index = function (obj, name, fields, unique) {
        if (obj.indices === undefined) {
            gqlAssert_1.default.raise("Expected an index on type " + obj.name + ", but found none.");
            return;
        }
        var indices = obj.indices.filter(function (x) { return x.name === name; });
        if (indices.length !== 1) {
            gqlAssert_1.default.raise("Expected exactly one index with name " + name + " on type " + obj.name + ", but found " + indices.length + ".");
        }
        var index = indices[0];
        expect(index.name).toBe(name);
        expect(index.unique).toBe(unique);
        expect(index.fields.sort()).toEqual(fields.sort());
    };
    /**
     * Assertion helper for directives.
     */
    SdlExpect.directive = function (obj, target) {
        expect(obj.directives).toBeDefined();
        if (obj.directives !== undefined) {
            var directive = obj.directives.filter(function (x) { return x.name === target.name; })[0];
            if (directive === undefined) {
                gqlAssert_1.default.raise("Directive " + target.name + " not found. Existing directives: " + obj.directives
                    .map(function (d) { return d.name; })
                    .join(', '));
            }
            expect(directive).toEqual(target);
            return directive;
        }
        else {
            throw new Error('This is a dummy to ensure correct type inferrence.');
        }
    };
    return SdlExpect;
}());
exports.SdlExpect = SdlExpect;
//# sourceMappingURL=index.js.map