"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var generator_1 = require("../../generator");
var prisma_datamodel_1 = require("prisma-datamodel");
var gqlAssert_1 = require("../../../util/gqlAssert");
var type_1 = require("graphql/type");
function createGraphQLScalarType(typeName) {
    return new type_1.GraphQLScalarType({ name: typeName, serialize: function () { return null; } });
}
// Theoretically, we could add properties like
// NOMINAL, ORDINAL, INTERVAL, RATIO and a special type for STRING
// And then generate all filter objects based on that, regardless of the
// actual type.
var scalarTypes = {};
scalarTypes[prisma_datamodel_1.TypeIdentifiers.string] = type_1.GraphQLString;
scalarTypes[prisma_datamodel_1.TypeIdentifiers.integer] = type_1.GraphQLInt;
scalarTypes[prisma_datamodel_1.TypeIdentifiers.long] = createGraphQLScalarType('Long');
scalarTypes[prisma_datamodel_1.TypeIdentifiers.float] = type_1.GraphQLFloat;
scalarTypes[prisma_datamodel_1.TypeIdentifiers.boolean] = type_1.GraphQLBoolean;
scalarTypes[prisma_datamodel_1.TypeIdentifiers.dateTime] = createGraphQLScalarType('DateTime');
scalarTypes[prisma_datamodel_1.TypeIdentifiers.id] = type_1.GraphQLID;
scalarTypes[prisma_datamodel_1.TypeIdentifiers.json] = createGraphQLScalarType('Json');
scalarTypes[prisma_datamodel_1.TypeIdentifiers.uuid] = createGraphQLScalarType('UUID');
// tslint:disable-next-line:max-classes-per-file
var ScalarTypeGenerator = /** @class */ (function (_super) {
    __extends(ScalarTypeGenerator, _super);
    function ScalarTypeGenerator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ScalarTypeGenerator.prototype.getTypeName = function (input, args) {
        if (typeof input === 'string') {
            return input;
        }
        else {
            return input.name;
        }
    };
    ScalarTypeGenerator.prototype.isScalarField = function (field) {
        var type = field.type;
        if (typeof type === 'string') {
            if (scalarTypes.hasOwnProperty(type)) {
                return true;
            }
            else {
                gqlAssert_1.default.raise(type + " is not a scalar type.");
                return false;
            }
        }
        else {
            return type.isEnum;
        }
    };
    ScalarTypeGenerator.prototype.mapToScalarFieldType = function (field) {
        var maybeListType = this.mapToScalarFieldTypeForceOptional(field);
        return this.requiredIf(field.isRequired || field.isList, maybeListType);
    };
    ScalarTypeGenerator.prototype.mapToScalarFieldTypeForInput = function (field) {
        var maybeListType = this.mapToScalarFieldTypeForceOptional(field);
        return this.requiredIf(this.isCreateInputFieldRequired(field), maybeListType);
    };
    ScalarTypeGenerator.prototype.isCreateInputFieldRequired = function (field) {
        if (field.isId) {
            if (field.idStrategy === prisma_datamodel_1.IdStrategy.None) {
                return true;
            }
            if (field.idStrategy === prisma_datamodel_1.IdStrategy.Auto) {
                return false;
            }
        }
        // all non id fields
        return (field.isRequired || field.isList) && field.defaultValue === null;
    };
    ScalarTypeGenerator.prototype.mapToScalarFieldTypeForceRequired = function (field) {
        var type = this.mapToScalarFieldTypeForceOptional(field);
        return new type_1.GraphQLNonNull(type);
    };
    ScalarTypeGenerator.prototype.mapToScalarFieldTypeForceOptional = function (field) {
        var type = this.generate(field.type, {});
        if (field.isList) {
            return this.wrapList(type);
        }
        else {
            return type;
        }
    };
    /**
     * This method intentionally ignores the required flag for lists,
     * as we generate some relation fields without the required flag.
     * @param field
     * @param type
     */
    ScalarTypeGenerator.prototype.wraphWithModifiers = function (field, type) {
        if (field.isList) {
            return this.wrapList(type);
        }
        else {
            return this.requiredIf(field.isRequired, type);
        }
    };
    ScalarTypeGenerator.prototype.wrapList = function (type) {
        return new type_1.GraphQLList(new type_1.GraphQLNonNull(type));
    };
    ScalarTypeGenerator.prototype.requiredIf = function (required, type) {
        if (required) {
            return new type_1.GraphQLNonNull(type);
        }
        else {
            return type;
        }
    };
    ScalarTypeGenerator.prototype.generateInternal = function (input, args) {
        if (typeof input === 'string') {
            if (!scalarTypes.hasOwnProperty(input)) {
                gqlAssert_1.default.raise(('Invalid scalar type given: ' + input));
            }
            return scalarTypes[input];
        }
        else {
            if (!input.isEnum) {
                gqlAssert_1.default.raise('Not an enum: ' + input.name);
            }
            return this.generators.modelEnumTypeGenerator.generate(input, {});
        }
    };
    return ScalarTypeGenerator;
}(generator_1.ScalarTypeGeneratorBase));
exports.default = ScalarTypeGenerator;
//# sourceMappingURL=scalarTypeGenerator.js.map