{"version":3,"file":"common.js","sourceRoot":"","sources":["../../src/plugins/common.ts"],"names":[],"mappings":"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","sourcesContent":["import FormData = require('form-data')\nimport { stringify as stringifyQuery, parse as parseQuery } from 'querystring'\nimport isHostObject from './is-host/index'\nimport { Request } from '../request'\nimport { Response } from '../response'\nimport form from '../form'\n\nconst JSON_MIME_REGEXP = /^application\\/(?:[\\w!#\\$%&\\*`\\-\\.\\^~]*\\+)?json$/i\nconst URL_ENCODED_MIME_REGEXP = /^application\\/x-www-form-urlencoded$/i\nconst FORM_MIME_REGEXP = /^multipart\\/form-data$/i\n\nconst JSON_PROTECTION_PREFIX = /^\\)\\]\\}',?\\n/\n\n/**\n * Simply wrap a value and return it.\n */\nexport function wrap <T> (value: T): () => T {\n  return () => value\n}\n\n/**\n * Remove default headers.\n */\nexport const headers = wrap(function (request: Request, next: () => Promise<Response>) {\n  // If we have no accept header set already, default to accepting\n  // everything. This is needed because otherwise Firefox defaults to\n  // an accept header of `html/xml`.\n  if (!request.get('Accept')) {\n    request.set('Accept', '*/*')\n  }\n\n  // Remove headers that should never be set by the user.\n  request.remove('Host')\n\n  return next()\n})\n\n/**\n * Stringify the request body.\n */\nexport const stringify = wrap(function (request: Request, next: () => Promise<Response>) {\n  const { body } = request\n\n  // Convert primitives types into strings.\n  if (Object(body) !== body) {\n    request.body = body == null ? null : String(body)\n\n    return next()\n  }\n\n  if (isHostObject(body)) {\n    return next()\n  }\n\n  let type = request.type()\n\n  // Set the default mime type to be JSON if none exists.\n  if (!type) {\n    type = 'application/json'\n\n    request.type(type)\n  }\n\n  // Automatically stringify expected MIME types.\n  try {\n    if (JSON_MIME_REGEXP.test(type)) {\n      request.body = JSON.stringify(body)\n    } else if (FORM_MIME_REGEXP.test(type)) {\n      request.body = form(body)\n    } else if (URL_ENCODED_MIME_REGEXP.test(type)) {\n      request.body = stringifyQuery(body)\n    }\n  } catch (err) {\n    return Promise.reject(request.error('Unable to stringify request body: ' + err.message, 'ESTRINGIFY', err))\n  }\n\n  // Remove the `Content-Type` header from form data requests. Browsers\n  // will only fill it automatically with the boundary when it isn't set.\n  if (request.body instanceof FormData) {\n    request.remove('Content-Type')\n  }\n\n  return next()\n})\n\nexport type ParseType = 'json' | 'urlencoded'\n\n/**\n * Parse the response body.\n */\nexport function parse (type: ParseType | ParseType[], strict?: boolean) {\n  const types = Array.isArray(type) ? type : [type]\n\n  for (const type of types) {\n    if (type !== 'json' && type !== 'urlencoded') {\n      throw new TypeError(`Unexpected parse type: ${type}`)\n    }\n  }\n\n  return function (request: Request, next: () => Promise<Response>) {\n    return next()\n      .then(function (response) {\n        const { body } = response\n        const responseType = response.type()\n\n        // Empty bodies are _always_ `null`.\n        if (body == null || body === '') {\n          response.body = null\n          return response\n        }\n\n        // Throw on invalid response type.\n        if (responseType == null) {\n          throw request.error(`Unable to parse empty response content type`, 'EPARSE')\n        }\n\n        // Error on non-string bodies.\n        if (typeof body !== 'string') {\n          throw request.error(`Unable to parse non-string response body`, 'EPARSE')\n        }\n\n        // Attempt to parse as each type.\n        for (const type of types) {\n          if (type === 'json' && JSON_MIME_REGEXP.test(responseType)) {\n            try {\n              response.body = JSON.parse(body.replace(JSON_PROTECTION_PREFIX, ''))\n            } catch (err) {\n              throw request.error(`Unable to parse response body: ${err.message}`, 'EPARSE', err)\n            }\n\n            return response\n          }\n\n          if (type === 'urlencoded' && URL_ENCODED_MIME_REGEXP.test(responseType)) {\n            response.body = parseQuery(body)\n            return response\n          }\n        }\n\n        if (strict !== false) {\n          throw request.error(`Unhandled response type: ${responseType}`, 'EPARSE')\n        }\n\n        return response\n      })\n  }\n}\n"]}