import { GraphQLScalarType, GraphQLType, GraphQLInterfaceType, GraphQLSchema, GraphQLFieldConfigMap, GraphQLInputObjectType, GraphQLFieldConfig, GraphQLObjectType, GraphQLInputFieldConfigMap, GraphQLInputFieldConfig, GraphQLFieldConfigArgumentMap, GraphQLEnumType, GraphQLEnumValueConfig, GraphQLEnumValueConfigMap } from 'graphql/type';
import { IGQLType, IGQLField } from 'prisma-datamodel';
import { GraphQLList, GraphQLNonNull } from 'graphql';
/**
 * Type cache for object types.
 */
export declare class TypeRegistry {
    [typeName: string]: GraphQLType;
}
/**
 * Base class of all generators,
 * has a reference to the set of generators we need
 * and a type registry.
 */
export declare abstract class Generator<In, Args, Out> {
    protected knownTypes: TypeRegistry;
    protected generators: IGenerators;
    constructor(knownTypes: TypeRegistry, generators: IGenerators);
    /**
     * Generates the thing this generator is generating.
     * @param model
     * @param args
     */
    abstract generate(model: In, args: Args): Out;
}
/**
 * Base class for all generators that create types.
 * This class implements caching via the given TypeRegistry.
 */
export declare abstract class TypeGenerator<In, Args, Type extends GraphQLType> extends Generator<In, Args, Type> {
    abstract getTypeName(input: In, args: Args): any;
    generate(input: In, args: Args): Type;
    protected abstract generateInternal(input: In, args?: Args): Type;
}
/**
 * Base class for all generators which map
 * a type from the datamodel to some object type.
 *
 * This class adds provides methods that assemble
 * a GraphQLObject type, for code re-use.
 *
 * Ideally a deriving class would override the
 * generateScalarFieldType or generateRelationFieldType methods.
 */
export declare abstract class TypeFromModelGenerator<Args, Type extends GraphQLType, FieldConfig extends GraphQLFieldConfig<any, any> | GraphQLEnumValueConfig | GraphQLInputFieldConfig, FieldConfigMap extends GraphQLFieldConfigMap<any, any> | GraphQLEnumValueConfigMap | GraphQLInputFieldConfigMap> extends TypeGenerator<IGQLType, Args, Type> {
    /**
     * Checks if the given list of fields has
     * a unique field.
     * @param fields
     */
    hasUniqueField(fields: IGQLField[]): boolean;
    /**
     * Checks if the given list of fields has
     * other fields than the fields given in the second
     * parameter.
     * @param fields
     * @param fieldNames
     */
    hasFieldsExcept(fields: IGQLField[], ...fieldNames: string[]): boolean;
    /**
     * Returns all fields needed for the create input in the given field list.
     * @param fields
     */
    getCreateInputFields(fields: IGQLField[]): IGQLField[];
    /**
     * Checks if the given field list contains at least one field that is used in the created input
     * @param fields
     */
    hasCreateInputFields(fields: IGQLField[]): boolean;
    /**
     * Returns all writeable fields in the given field list.
     * @param fields
     */
    getWriteableFields(fields: IGQLField[]): IGQLField[];
    /**
     * Checks if the given field list contains at least one writeable field.
     */
    hasWriteableFields(fields: IGQLField[]): boolean;
    /**
     * Checks if the given list of fields contains at least one scalar field.
     * @param fields
     */
    hasScalarFields(fields: IGQLField[]): boolean;
    /**
     * Returns all scalar fields from the given field list.
     * @param fields
     */
    getScalarFields(fields: IGQLField[]): IGQLField[];
    /**
     * Returns all scalar fields from the given field list.
     * @param fields
     */
    getRelationFields(fields: IGQLField[]): IGQLField[];
    /**
     * Indicates if the resulting type would be empty.
     * @param model
     * @param args
     */
    wouldBeEmpty(model: IGQLType, args: Args): boolean;
    /**
     * Generates all fields of this type.
     * @param model
     * @param args
     */
    protected generateFields(model: IGQLType, args: Args): FieldConfigMap;
    /**
     * Responsible to instantiate the correct GraphQL type
     * for building the ast.
     * @param name
     * @param fields
     */
    protected abstract instantiateObjectType(name: string, fields: () => FieldConfigMap): any;
    /**
     * Calls generateFields and wraps the result into a function.
     * Then calls instantiateObjectType to create the actual AST node.
     * @param model
     * @param args
     */
    protected generateInternal(model: IGQLType, args: Args): Type;
    protected generateScalarField(model: IGQLType, args: Args, field: IGQLField): FieldConfig | null;
    protected generateRelationField(model: IGQLType, args: Args, field: IGQLField): FieldConfig | null;
    protected generateScalarFieldType(model: IGQLType, args: Args, field: IGQLField): GraphQLType | null;
    protected generateRelationFieldType(model: IGQLType, args: Args, field: IGQLField): GraphQLType | null;
}
/**
 * Base class for all generators that generate GraphQLEnums.
 */
export declare abstract class ModelEnumTypeGeneratorBase extends TypeFromModelGenerator<{}, GraphQLEnumType, GraphQLEnumValueConfig, GraphQLEnumValueConfigMap> {
    protected instantiateObjectType(name: string, values: () => GraphQLEnumValueConfigMap): GraphQLEnumType;
}
/**
 * Base class for all generators that generate GraphQLObjectTypes.
 */
export declare abstract class ModelObjectTypeGeneratorBase<Args> extends TypeFromModelGenerator<Args, GraphQLObjectType, GraphQLFieldConfig<any, any>, GraphQLFieldConfigMap<any, any>> {
    protected instantiateObjectType(name: string, fields: () => GraphQLFieldConfigMap<any, any>): GraphQLObjectType;
}
export declare abstract class ModelObjectTypeGenerator extends ModelObjectTypeGeneratorBase<{}> {
}
/**
 * Base class for all generators that generate GraphQLInputObjectTypes.
 */
export declare abstract class ModelInputObjectTypeGeneratorBase<Args> extends TypeFromModelGenerator<Args, GraphQLInputObjectType, GraphQLInputFieldConfig, GraphQLInputFieldConfigMap> {
    protected instantiateObjectType(name: string, fields: () => GraphQLInputFieldConfigMap): GraphQLInputObjectType;
}
export declare abstract class ModelInputObjectTypeGenerator extends ModelInputObjectTypeGeneratorBase<{}> {
}
/**
 * Special base class for the scalar field generator.
 */
export declare abstract class ScalarTypeGeneratorBase extends TypeGenerator<string | IGQLType, {}, GraphQLScalarType> {
    abstract isScalarField(field: IGQLField): boolean;
    /**
     * Maps a field to the scalar field type for output objects.
     * @param field
     */
    abstract mapToScalarFieldType(field: IGQLField): GraphQLType;
    /**
     * Maps a field to the scalar field type for input objects.
     * @param field
     */
    abstract mapToScalarFieldTypeForInput(field: IGQLField): GraphQLType;
    /**
     * Maps a field to the scalar field type, forces the field to be not nullable.
     * @param field
     */
    abstract mapToScalarFieldTypeForceRequired(field: IGQLField): GraphQLType;
    /**
     * Maps a field to the scalar field type, forces the field to be nullable.
     * @param field
     */
    abstract mapToScalarFieldTypeForceOptional(field: IGQLField): GraphQLType;
    /**
     * Transforms a given GraphQLScalarType into a list of the given type, according
     * to the OpenCRUD spec.
     * @param field
     */
    abstract wrapList<T extends GraphQLType>(field: T): GraphQLList<GraphQLNonNull<T>>;
    abstract requiredIf<T extends GraphQLType>(condition: boolean, field: T): T | GraphQLNonNull<T>;
    abstract wraphWithModifiers<T extends GraphQLType>(field: IGQLField, type: T): T | GraphQLList<GraphQLNonNull<T>> | GraphQLNonNull<T>;
}
/**
 * Abstract base class for all generators that generate scalar input fields.
 */
export declare abstract class ScalarInputGenerator extends TypeGenerator<IGQLType, IGQLField, GraphQLObjectType> {
}
/**
 * Base class for generators that generate argument lists.
 */
export declare abstract class ArgumentsGenerator extends Generator<IGQLType, {}, GraphQLFieldConfigArgumentMap> {
    wouldBeEmpty(model: IGQLType, args: {}): boolean;
}
/**
 * Arguments passed to generators that need to take a related field into account.
 */
export declare class RelatedGeneratorArgs {
    relatedField: IGQLField;
    relatedType: IGQLType;
    relationName: string | null;
}
/**
 * Base class for generators that generate GraphQLObject types which take a related field into account.
 */
export declare abstract class RelatedModelInputObjectTypeGenerator extends ModelInputObjectTypeGeneratorBase<RelatedGeneratorArgs> {
}
/**
 * Base class for generators that generate a GraphQLObjectType without taking any input.
 */
export declare abstract class AuxillaryObjectTypeGenerator extends TypeGenerator<null, {}, GraphQLObjectType> {
}
/**
 * Base class for generators that generate a GraphQLInterfaceType without taking any input.
 */
export declare abstract class AuxillaryInterfaceGenerator extends TypeGenerator<null, {}, GraphQLInterfaceType> {
}
/**
 * Base class for generators that generate a GraphQLInputObjectType without taking any input.
 */
export declare abstract class AuxillaryInputObjectTypeGenerator extends TypeGenerator<null, {}, GraphQLInputObjectType> {
}
/**
 * Base class for generators that generate a GraphQLEnumType without taking any input.
 */
export declare abstract class AuxillaryEnumGenerator extends TypeGenerator<null, {}, GraphQLEnumType> {
}
/**
 * Base class for generators that generate a query, mutation or subscription object from
 * a list of datamodel types.
 */
export declare abstract class RootGenerator extends TypeGenerator<IGQLType[], {}, GraphQLObjectType> {
}
/**
 * Base class for generators that generate a schema from a list of datamodel types.
 */
export declare abstract class SchemaGeneratorBase extends Generator<IGQLType[], {}, GraphQLSchema> {
}
/**
 * Base class specifying a list of generators to implement.
 */
export interface IGenerators {
    modelCreateInput: ModelInputObjectTypeGenerator;
    modelCreateOneInput: ModelInputObjectTypeGenerator;
    modelCreateManyInput: ModelInputObjectTypeGenerator;
    modelCreateWithoutRelatedInput: RelatedModelInputObjectTypeGenerator;
    modelCreateOneWithoutRelatedInput: RelatedModelInputObjectTypeGenerator;
    modelCreateManyWithoutRelatedInput: RelatedModelInputObjectTypeGenerator;
    scalarListCreateInput: ScalarInputGenerator;
    modelUpdateInput: ModelInputObjectTypeGenerator;
    modelUpdateDataInput: ModelInputObjectTypeGenerator;
    modelUpdateManyDataInput: ModelInputObjectTypeGenerator;
    modelUpdateOneInput: ModelInputObjectTypeGenerator;
    modelUpdateOneRequiredInput: ModelInputObjectTypeGenerator;
    modelUpdateManyInput: ModelInputObjectTypeGenerator;
    modelUpdateManyMutationInput: ModelInputObjectTypeGenerator;
    modelUpdateWithoutRelatedDataInput: RelatedModelInputObjectTypeGenerator;
    modelUpdateOneWithoutRelatedInput: RelatedModelInputObjectTypeGenerator;
    modelUpdateOneRequiredWithoutRelatedInput: RelatedModelInputObjectTypeGenerator;
    modelUpdateManyWithoutRelatedInput: RelatedModelInputObjectTypeGenerator;
    scalarListUpdateInput: ScalarInputGenerator;
    modelUpdateWithWhereUniqueWithoutRelatedInput: RelatedModelInputObjectTypeGenerator;
    modelUpdateWithWhereUniqueNestedInput: ModelInputObjectTypeGenerator;
    modelUpdateManyWithWhereNestedInput: ModelInputObjectTypeGenerator;
    modelUpsertNestedInput: ModelInputObjectTypeGenerator;
    modelUpsertWithWhereUniqueWithoutRelatedInput: RelatedModelInputObjectTypeGenerator;
    modelUpsertWithoutRelatedInput: RelatedModelInputObjectTypeGenerator;
    modelUpsertWithWhereUniqueNestedInput: ModelInputObjectTypeGenerator;
    modelWhereUniqueInput: ModelInputObjectTypeGenerator;
    modelScalarWhereInput: ModelInputObjectTypeGenerator;
    modelWhereInput: ModelInputObjectTypeGenerator;
    modelRestrictedWhereInput: ModelInputObjectTypeGenerator;
    modelOrderByInput: ModelEnumTypeGeneratorBase;
    modelConnection: ModelObjectTypeGenerator;
    modelEdge: ModelObjectTypeGenerator;
    aggregateModel: ModelObjectTypeGenerator;
    pageInfo: AuxillaryObjectTypeGenerator;
    model: ModelObjectTypeGenerator;
    oneQueryArguments: ArgumentsGenerator;
    manyQueryArguments: ArgumentsGenerator;
    uniqueQueryArguments: ArgumentsGenerator;
    node: AuxillaryInterfaceGenerator;
    batchPayload: AuxillaryObjectTypeGenerator;
    modelSubscriptionPayload: ModelObjectTypeGenerator;
    modelSubscriptionWhereInput: ModelInputObjectTypeGenerator;
    mutationType: AuxillaryEnumGenerator;
    modelPreviousValues: ModelObjectTypeGenerator;
    query: RootGenerator;
    mutation: RootGenerator;
    subscription: RootGenerator;
    schema: SchemaGeneratorBase;
    modelEnumTypeGenerator: ModelEnumTypeGeneratorBase;
    scalarTypeGenerator: ScalarTypeGeneratorBase;
}
/**
 * Utility class that merges field configration.
 */
export declare class FieldConfigUtils {
    /**
     * Merges all given field config maps.
     * @param fieldMaps The field config maps to merge.
     */
    static merge<T extends GraphQLFieldConfigMap<any, any> | GraphQLInputFieldConfigMap>(...fieldMaps: T[]): T;
}
